# -*- mode: shell-script -*-

set -eu

error_exit() {
    ${2+:} false && echo "${0##*/}: $2" 1>&2
    exit $1
}

exit_trap() {
    set -- ${1:-} $?  # $? is set as $1 if no argument given
    trap '' EXIT HUP INT QUIT PIPE ALRM TERM
    [ -d "${Tmp:-}" ] && rm -rf "${Tmp%/*}/_${Tmp##*/_}"
    trap -  EXIT HUP INT QUIT PIPE ALRM TERM
    exit $1
}

print_and_exec() (
    PS4=$( (set -x; :) 2>&1 | sed 's/:$//')
    echo "${PS4}${*}" 1>&2
    PS4=$(printf '%s' "${PS4}" | sed 's/\(.\) $/\1\0/')
    PS4="${PS4}" "${@}"
)

git_upgrade() {
    eval $(print_and_exec ssh-agent)
    print_and_exec ssh-add
    cat "${LIST_FILE}" |
        while IFS= read repo; do (
            cd "${LIST_FILE%/*}"
            cd "${repo}" || continue
            print_and_exec : git pull: "$(pwd)"
            git pull origin "$(git rev-parse --abbrev-ref HEAD)" || continue
        ); done
    print_and_exec ssh-agent -k
}

update_list() {
    trap 'exit_trap' EXIT HUP INT QUIT PIPE ALRM TERM
    Tmp=$(mktemp -t "_${0##*/}.$$.XXXXXXXXXXX") || error_exit 1 'Failed to mktemp'
    cat | sort | uniq > "${Tmp}"
    mv "${Tmp}" "${LIST_FILE}"
}

get_list() {
    cat "${LIST_FILE}"
}

Homedir="$(d=${0%/*}/; [ "_$d" = "_$0/" ] && d='./'; cd "$d.."; pwd)"
LIST_FILE="${Homedir}/plugins/git.d/list"

subcmd="${1}"

case "${subcmd}" in
    upgrade) git_upgrade "${@}" ;;
    pm-list) update_list ;;
    pm-get-list) get_list ;;
esac
