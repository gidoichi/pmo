# -*- mode: shell-script -*-

set -eu

error_exit() {
    ${2+:} false && echo "${0##*/}: $2" 1>&2
    exit $1
}

exit_trap() {
    set -- ${1:-} $?  # $? is set as $1 if no argument given
    trap '' EXIT HUP INT QUIT PIPE ALRM TERM
    [ -d "${Tmp:-}" ] && rm -rf "${Tmp%/*}/_${Tmp##*/_}"
    trap -  EXIT HUP INT QUIT PIPE ALRM TERM
    exit $1
}

print_and_exec() (
    (set -x; : "${@}")
    "$@"
)

git_upgrade() {
    if [ ! -f "${LIST_FILE}" ] || [ "$(du -k "${LIST_FILE}" | awk '{print $1}')" -eq 0 ]; then
        return
    fi

    upagent=0
    if [ -z ${SSH_AUTH_SOCK+_} ] && [ -z ${SSH_AGENT_PID+_} ]; then
        upagent=1
        eval $(print_and_exec ssh-agent)
        print_and_exec ssh-add
    fi

    repos="$(cat "${LIST_FILE}")"
    code=0
    i=0
    l=$(printf '%s' "${repos}" | tr ':' '\n' | wc -l)
    while [ "${i}" -le "${l}" ]; do
        repo=$(printf '%s\n' "${repos}" | tr ':' '\n' | sed -n "$((i+1))p")
        if ! (
                cd "${LIST_FILE%/*}"
                cd "${repo}" || return 1
                print_and_exec git pull "$(git remote get-url origin)" "$(git rev-parse --abbrev-ref HEAD)"
            ) </dev/tty; then
            code=1
        fi
        i=$((i+1))
    done

    if [ "${upagent}" -ne 0 ]; then
        upagent=0
        print_and_exec ssh-agent -k
    fi

    return "${code}"
}

update_list() {
    trap 'exit_trap' EXIT HUP INT QUIT PIPE ALRM TERM
    Tmp=$(mktemp -t "_${0##*/}.$$.XXXXXXXXXXX") || error_exit 1 'Failed to mktemp'
    cat | sort | uniq > "${Tmp}"
    mv "${Tmp}" "${LIST_FILE}"
}

list() {
    cat "${LIST_FILE}"
}

Homedir="$(d=${0%/*}/; [ "_$d" = "_$0/" ] && d='./'; cd "$d.."; pwd)"
LIST_FILE="${Homedir}/plugins/git.d/list"

subcmd="${1}"

case "${subcmd}" in
    upgrade) git_upgrade "$@" ;;
    pm-list-save) update_list ;;
    list) list ;;
esac
